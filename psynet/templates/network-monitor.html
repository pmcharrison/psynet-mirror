<!doctype html>
<html>
<head>
    <title>Network | Monitor </title>

    <style type="text/css">
        body {
            font: 10pt sans;
        }

        #mynetwork {
            width: 1200px;
            height: 600px;
            border: 1px solid lightgray;
        }
    </style>
    <!-- NORI: I CHANGED THIS TO STATIC REFERENCE FOR PERFORMANCE -->

    <link   rel="stylesheet" href="/static/css/font-awesome.min.css">
    <link   rel="stylesheet" href="/static/css/vis-network.min.css">
    <script src="/static/scripts/vis.min.js" type="text/javascript"></script>

    <!-- NORI: IN CASE YOU WANT TO NOT CHANGE STATIC LINK USE THIS -->
    <!-- <link   rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
         <script src="https://unpkg.com/vis@4.17.0/dist/vis.min.js" type="text/javascript"></script>
         <link   href="https://unpkg.com/vis@4.17.0/dist/vis-network.min.css" rel="stylesheet" type="text/css"/> -->


    <script type="text/javascript">
        var nodes = null;
        var edges = null;
        var network = null;
        var ndata = {{ my_data |safe }}; // this  is a container for all the data coming from the route

        Array.prototype.unique = function() {
          return this.filter(function (value, index, self) { 
            return self.indexOf(value) === index;
          });
        }

      function participants_for_node(ndata,node_id) {
      info_for_node=[];for (var i = 0; i< ndata.net_structure.infos.length; i++) {
                  info=ndata.net_structure.infos[i];  if (info.origin_id==node_id) info_for_node=info_for_node.concat([parseInt(info.property1)]); }; info_for_node=info_for_node.unique();
                  return info_for_node;}

        /// set display options and groups: this will modify the way the network show up.
        function getOptions() {
          var options = {
            layout: {
                improvedLayout: false,
                 hierarchical: {
                     direction: 'UD',
                     sortMethod: 'directed',
                     edgeMinimization: false, // this is super important as of a bug in the library
                     nodeSpacing: 80, // important due to a bug in the library
                     treeSpacing: 200 // important due to a bug in the librarys
                 }
             },
             interaction: {dragNodes :false},
             physics: {
                enabled: false,
                stabilization:  false
             },
                        edges: {
                                width: 2
                        },

                        groups: {
                                failed_nodes: {
                                    color: 'red'
                                },
                                good_nodes: {
                                    font: {
                                          color: '#ffffff'
                                        }
                                },
                                failed_sources: {
                                    color: 'red',
                                    color: {background:'red', border:'black'},
                                    border: 5,
                                    size: 30
                                },
                                good_sources: {
                                    color: {background:'blue', border:'black'},
                                    border: 5,
                                    size: 30,
                                    font: {
                                          color: '#ffffff'
                                    }
                                },
                                group_networks_open: {
                                    shape: 'icon',
                                    icon: {
                                        face: 'FontAwesome',
                                        code: '\uf0c2',
                                        size: 80,
                                        color: 'green'
                                    },
                                     font: {
                                          size: 14,
                                          color: 'green'
                                        }
                                },

                                 group_networks_close: {
                                    shape: 'icon',
                                    icon: {
                                        face: 'FontAwesome',
                                        code: '\uf0c2',
                                        size: 80,
                                        color: 'rgb(0,0,100)'
                                    },
                                     font: {
                                          size: 14,
                                          color: 'blue'
                                        }
                                },

                                group_father: {
                                    shape: 'icon',
                                    icon: {
                                        face: 'FontAwesome',
                                        code: '\uf0c2',
                                        size: 120,
                                        color: 'green'
                                    },
                                    font: {
                                          size: 25,
                                          color: '#000000'
                                        }
                                },

                                good_infos: {
                                    shape: 'icon',
                                    icon: {
                                        face: 'FontAwesome',
                                        code: '\uf0e5',
                                        size: 30,
                                        color:'blue'
                                    }
                                },
                                failed_infos: {
                                    shape: 'icon',
                                    icon: {
                                        face: 'FontAwesome',
                                        code: '\uf0e5',
                                        size: 30,
                                        color: 'red'
                                    }
                                },

                            }
                    }
                    return options
        }

        /// Draw the network
        /// This long function is drawing the network structure.
        function getnNetwork() {
          var nodes = []; // list of all nodes
          var edges = []; // list of all edges
          var list_of_nodes=[]; // list of objects with nodes (not only nodes for example networks)
          var list_of_participants=[]; // list of objects with participants
          var list_of_node_indx=[]; // list of objects with nodes
          var map_infoid_to_infonum=[]; // map info id  to nodes in the visualization

          /// These lines finds all the roles that involved  in this networks (typically "experiment"/"practice" but this is general)
          roles=[]; // list of unique roles
          networks_roles=[]; // the role of each network
          for (var i = 0; i< ndata.net_structure.networks.length; i++) {
                          net=ndata.net_structure.networks[i];
                          my_role=net.role

                          is_found = false;
                          for (var j=0;j<roles.length;j++) {
                            if (my_role.localeCompare(roles[j])==0) {
                              is_found=true;
                              break;
                            }

                          }
                        if (!is_found) {

                              networks_roles[net.id]=roles.length;
                              roles[roles.length]=my_role;

                        } else{
                          networks_roles[net.id]=j;
                        }
          }

          roles_colors=[]; ///  assign pseudorandom colors for each role
          for (var j=0;j<roles.length;j++) {
            rr= 50 + (((j+3)*11557)  % 200); // pseudorandom colors
            gg= 50 + (((j+3171)*31511) % 200);
            bb= 50 +  (((j+371)*11517) % 200);
            clr='rgb('+String(rr)+','+ String(gg)+',' + String (bb)+')';
            roles_colors[j]=clr;
          }

          // find all participants and make list, also asigned unique colors to participants
          for (var i = 0; i< ndata.net_structure.participants.length; i++) {
            participant=ndata.net_structure.participants[i];
            participant_id=participant.id;
            if (participant_id==null) {
              participant_id=0;
              participant='<empty>';
            }
            rr= 10 +  (((i+357)*2551)  % 150); // pseudorandom colors
            gg= 30 +  (((i+3571)*2511) % 200);
            bb= 100 + (((i+3571)*2511) % 150);
            participant.clr='rgb('+String(rr)+','+ String(gg)+',' + String (bb)+')'
            list_of_participants[participant_id]=participant;
          }

          // preperation to push to the graph all nodes from the data
          count_nodes=0;
          for (var i = 0; i< ndata.net_structure.nodes.length; i++) {
              node=ndata.net_structure.nodes[i];
              count_nodes++; // count the nodes
              list_of_nodes[node.id]=node;
              list_of_node_indx[node.id]=count_nodes;

              /// find if the node is a source:
              if (node.type.toLowerCase().search('source')>0) {
                msg='source:'
                 if (node.failed) {
                  mgroup='failed_sources'
                } else {
                  mgroup='good_sources'
                }
              } else {
                msg=''
                 if (node.failed) {
                  mgroup='failed_nodes'
                } else {
                  mgroup='good_nodes'
                }
              }

              // find participant and show it on the graph
              participant_id=node.participant_id
              participant={}
               if (participant_id==null) {
                participant_id=0;
                if (!node.failed) {
                  participant.clr='blue'
                }
                //// ADNADN
                 pn=participants_for_node(ndata,node.id);
                if (pn.length==1) {
                    participant_id=pn[0];
                    participant=list_of_participants[participant_id];
                } else {
                    if (pn.length>1) {
                        participant.clr='green' 
                    }

                }
                //// ADNADN
              } else {
                participant=list_of_participants[participant_id];
                }
               if (node.failed) {
                clr='red';
              } else {
                clr=participant.clr
              }

             // actually push the node to node list
              nodes.push({
                id: list_of_node_indx[node.id],
                label: msg+String(node.id), color:clr,
                title: ('<pre><code><font size="-2">'+ JSON.stringify(node, null, 2) + '</font></code></pre>'),
                group: mgroup,
                font: {align: 'inside'}
              });
            }

            // create edges for vectors
            for (var i = 0; i< ndata.net_structure.vectors.length; i++) {
              vector=ndata.net_structure.vectors[i]
              var from = vector.origin_id;
              var to = vector.destination_id;
              if (vector.failed) {
                mclr='red'
              } else {
              mclr='blue'
              }
              edges.push({
                from: list_of_node_indx[from],
                to: list_of_node_indx[to],
                arrows:'to',
                title: ('<pre><code><font size="-2">'+ JSON.stringify(vector, null, 2) + '</font></code></pre>'),
                color: mclr
              });
            }

            // now pushes infos
            for (var i = 0; i< ndata.net_structure.infos.length; i++) {
              info=ndata.net_structure.infos[i];
              count_nodes++;
              map_infoid_to_infonum[info.id]=count_nodes

              my_node_id=count_nodes;
              to=my_node_id;
              from=info.origin_id;
              //participant_id=list_of_nodes[from].participant_id
              participant_id=parseInt(info.property1)
              participant={}
              if (participant_id==null) {
                participant_id=0;
                participant.clr='black';
                participant='<empty>';
              } else {
                participant=list_of_participants[participant_id];
                }
               if (info.failed) {
                mgroup='failed_infos'
              } else {
                mgroup='good_infos'
              }
              nodes.push({
                id: my_node_id,
                label: "info:"+ String(info.id), dashes:true,
                title: ('<pre><code><font size="-2">'+ JSON.stringify(info, null, 2) + '</font></code></pre>'),
                group: mgroup,
                font: {align: 'inside'},
                icon: {color: participant.clr}

              });
              if (participant_id>0) {
                edges.push({
                from: list_of_node_indx[from],
                to: to,
                dashes:true,
                label: "participant: "+ String(participant_id), font: {size:15, color:participant.clr, strokeWidth:0, strokeColor:'yellow',align: 'top'},
                //arrows:'to', dashes:true,
                title: ('<pre><code><font size="-2">'+ JSON.stringify(participant, null, 2) + '</font></code></pre>'),
                color: participant.clr
              });
              } else {
              edges.push({
                from: list_of_node_indx[from],
                to: to,
                dashes:true,
              });
              }
            }

            // create edges for transformation
            for (var i = 0; i< ndata.net_structure.trans.length; i++) {
              tran=ndata.net_structure.trans[i]
              var from = tran.origin_id;
              var to = tran.destination_id;
              var from_n=map_infoid_to_infonum[from];
              var to_n=map_infoid_to_infonum[to];

              if (tran.failed) {
                rr=200
                gg=100
                bb=100
                mclr='rgb('+String(rr)+','+ String(gg)+',' + String (bb)+')'
              } else {
                //mclr='black'
                rr=200
                gg=200
                bb=200
                mclr='rgb('+String(rr)+','+ String(gg)+',' + String (bb)+')'
              }
              edges.push({
                from: from_n,
                to: to_n,
                arrows:'to',
                dashes:true,
                title: ('<pre><code><font size="-2">'+ JSON.stringify(tran, null, 2) + '</font></code></pre>'),
                color: mclr
              });
            }

          // This is needed to group networks according to roles
          // we used "father" for all the network and connect it
          // so the visualization will group things according to their role
          group_fathres=[];
          for (var j=0;j<roles.length;j++) {
             //group fathers of all practice networks
             count_nodes++;
            my_node_id=count_nodes;
            clr=roles_colors[j]
            gtitle=roles[j] + ' networks'

            nodes.push({
                    id: my_node_id,
                    label: gtitle,
                    title: gtitle,
                    group: 'group_father',
                    font: {align: 'inside'},
                    icon: {
                                        face: 'FontAwesome',
                                        code: '\uf0c2',
                                        size: 120,
                                        color: clr
                                    }
                  });
                  group_fathres[j]=my_node_id;
          }


          //connect network to correct source (or father)
          for (var i = 0; i< ndata.net_structure.networks.length; i++) {
                net=ndata.net_structure.networks[i];
                count_nodes++;
                my_node_id=count_nodes;
                from=my_node_id;
                is_found=false;

                min_id=99999999
                // find the node with minimal id that belong to this network
                for (var j = 0; j< ndata.net_structure.nodes.length; j++) {
                  node=ndata.net_structure.nodes[j];
                    if ((node.id<=min_id) && (node.network_id==net.id))  {
                      min_id=node.id
                      to_min=list_of_node_indx[node.id]

                    }
                }

                // find the source that belong to this network
                for (var j = 0; j< ndata.net_structure.nodes.length; j++) {
                  node=ndata.net_structure.nodes[j];
                    if ((node.type.toLowerCase().search('source')>0) && (node.network_id==net.id))  {
                      is_found=true
                      to=list_of_node_indx[node.id]
                      break
                    }
                }

                if (!is_found) {
                  to=to_min // use a default strategy that the source is the minimal id
                    //to=my_node_id
                }

                  if (net.property1=='True') { // assume that there is a feature in property1 that decide if a network is open or close
                      mgroup='group_networks_open';
                    } else {
                      mgroup='group_networks_close';
                    }

                    father=group_fathres[networks_roles[net.id]]; // find father network
                    clr=roles_colors[networks_roles[net.id]];
                nodes.push({
                  id: my_node_id,
                  label: "network:"+ String(net.id),
                  title: ('<pre><code><font size="-2">'+ JSON.stringify(net, null, 2) + '</font></code></pre>'),
                  group: mgroup,
                  font: {align: 'inside'},
                  icon: {
                                        face: 'FontAwesome',
                                        code: '\uf0c2',
                                        color: clr
                                    }

                });
                 edges.push({
                  from: from,
                  to: to,
                  color: 'black'
                });
                 //connect network to father
                edges.push({
                  from: father,
                  to: from,
                  color: 'white',
                  font: {align: 'inside'}
                });

            }

          return {nodes:nodes, edges:edges};
        }

        function get_network_data() {
            //document.getElementById('debug').innerHTML=ndata;
            draw();

        }
        function destroy() {
            if (network !== null) {
                network.destroy();
                network = null;
            }
        }

        function draw() {

            destroy();

            var data = getnNetwork()

            // create a network
            var container = document.getElementById('mynetwork');

            var options=getOptions();
            network = new vis.Network(container, data, options);

            // add event listeners
            network.on('select', function (params) {
                document.getElementById('selection').innerHTML = 'Selection: ' + params.nodes;
            });
        }

    </script>

</head>

<body onload="get_network_data();">


<h2><i class="fa fa-cloud"></i> Network Monitor</h2>
<div id="stats">
{{ my_msg |safe }}
</div>
Zoom in to see details:

<br>

<div id="mynetwork"></div>

<div id="debug"></div>
</body>
</html>
