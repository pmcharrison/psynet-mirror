{% extends "macros.html" %}

{% block stylesheets %}
    {{ super() }}
    <style>
        .modal {
            display: none;
            position: fixed;
            padding-top: 100px;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgb(0, 0, 0);
            background-color: rgba(0, 0, 0, 0.4);
        }

        #help_modal {
            z-index: 1000;
        }

        .modal-content {
            background-color: white;
            color: black;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
        }

        .close {
            color: #aaaaaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .loader {
            border: 16px solid #f3f3f3; /* Light grey */
            border-top: 16px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 120px;
            height: 120px;
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .vspace {
            height: 25px;
            margin: 0px
        }
    </style>

    {% for x in css %}
        <style>
            {{ x }}
        </style>
    {% endfor %}
{% endblock %}

{% block body %}
    {% block header %}
        <div class="header">
            {% if experiment_progress_bar.show %}
                <div class="progress">
                    <div class="progress-bar" role="progressbar"
                         aria-valuenow="{{ experiment_progress_bar.percentage }}"
                         aria-valuemin="0" aria-valuemax="100" style="width:{{ experiment_progress_bar.percentage }}%">
                        {{ experiment_progress_bar.percentage }}%
                    </div>
                </div>
            {% endif %}
        </div>
    {% endblock %}

    <div id="main-body" style="padding: 5% 10% 5% 10%">
        {% block main_body %}

            {% block above_progress_display %}
            {% endblock %}

            {% block trial_progress_display %}
                <style>
                    #trial-progress-bar {
                        margin-top: 15px;
                        margin-bottom: 15px;
                        display: {% if trial_progress_display_config["show_bar"] %} flex {% else %} none {% endif %};
                    }
                    #trial-progress-caption {
                        margin-top: 15px;
                        margin-bottom: 15px;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        font-weight: bold;
                    }
                    .trial-progress-bar-segment {
                        -webkit-transition: none;
                        -moz-transition: none;
                        -ms-transition: none;
                        -o-transition: none;
                        transition: none;
                    }
                </style>

                <div id="trial-progress-bar" class="progress"></div>
                <div id="trial-progress-caption">
                    <span id="trial-progress-caption-contents">&nbsp;</span>
                </div>
            {% endblock %}

            {% block below_progress_display %}
            {% endblock %}

        {% endblock %}

        <span id="psynet-event-listener"></span>
    </div>

    {% block modals %}
        {% block help_modal %}
            <div id="help_modal" class="modal">
                <div class="modal-content">
                    <span class="close">&times;</span>
                    <div style="margin: 20px">
                        <h3>In case of a problem, try the following:</h3>
                        <ul>
                            <li>Reload the page.</li>
                            <li>Check that your internet connection is working.</li>
                            <li>If the above doesn't help,
                                <a
                                href="mailto:{{ contact_email_on_error }}?Subject=Problem%20with%20experiment%20%28App%20ID%3A%20{{ app_id }}%2C%20Worker%20ID%3A%20{{ worker_id }}%2C%20Participant%20ID%3A%20{{ participant.id }}%29"
                                target="_top">send us an email</a>
                                with the following information:
                                <ol>
                                    <li>A link to the current web page;</li>
                                    <li>Your Worker ID;</li>
                                    <li>The problem you're experiencing.</li>
                                </ol>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        {% endblock %}

        {% block resume_modal %}
            <div id="resume_modal" class="modal">
                <div class="modal-content">
                    <h3>Are you ready?</h3>
                    <p>
                        Click the button when you're ready to continue the experiment.
                    </p>
                    <button type="button" style="max-width: 100px" class="btn btn-primary" id="resume_button">
                        Resume
                    </button>
                </div>
            </div>
        {% endblock %}
    {% endblock %}

    {% block footer %}
        {% if footer.show %}
            <style>
                #footer {
                    background-color: rgb(49, 124, 246);
                    color: white;
                    margin: 0px;
                    padding: 0px;
                    line-height: 33px;
                    border-style: none;
                }
                #media_download_progress_bar {
                    width: {{ initial_download_progress }}%;
                    height: 6px;
                    background-color: black;
                }
                .footer-text {
                    margin: 0px;
                }
                #help_button {
                    min-width: 50px;
                    background-color: white;
                    color: black
                }
                #help_button:hover {
                    background-color: rgb(234, 236, 239);
                }
            </style>

            <nav id="footer" class="navbar fixed-bottom">
                <div id="media_download_progress_bar"></div>
                <div style="width: 100%; padding: 8px; padding-left: 20px; padding-right: 20px;">
                    <div style="margin: 0px; display: flex; justify-content: space-between; align-items: center;">
                        {% for text in footer.text_to_show %} <div class="footer-text"> {{ text }} </div> {% endfor %}
                        <button type="button" class="btn btn-primary" id="help_button">Help!</button>
                    </div>
                </div>
            </nav>
        {% endif %}
    {% endblock %}
{% endblock %}

{% block head %}
    {{ super() }}

    <script src="https://code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

    <script>
        {{ init_js_vars }}
        var psynet = (function () {
                /**
                 * @namespace
                 * @alias psynet
                 */

                var psynet = {
                    media: {},
                    page: {
                        prompt: {},
                        control: {}
                    },
                    utils: {}
                };

                psynet.utils.shallow_copy = function(x) {
                    return Object.assign({}, x);
                }

                psynet.utils.deep_copy = function(x) {
                    return JSON.parse(JSON.stringify(x));
                }

                // check if it is a function
                psynet.utils.is_function = function (functionToCheck) {
                    return functionToCheck !== null &&
                        functionToCheck &&
                        {}.toString.call(functionToCheck) === '[object Function]';
                };

                // Checks which value in the haystack is closest to the needle
                psynet.utils.closest = function (needle, haystack) {
                    var best_value;
                    var best_dist;
                    var best_i;
                    for (var i = 0; i < haystack.length; i++) {
                        var proposal = haystack[i];
                        var dist = Math.abs(proposal - needle);
                        if (best_dist == undefined || dist < best_dist) {
                            best_value = proposal;
                            best_dist = dist;
                            best_i = i;
                        }
                    }
                    return {
                        value: best_value,
                        dist: best_dist,
                        index: best_i
                    }
                };

                // check if it is a dictionary
                psynet.utils.is_dict = function (dict_to_check) {
                    return (
                        typeof dict_to_check === 'object' &&
                        dict_to_check !== null &&
                        !(dict_to_check instanceof Array) &&
                        !(dict_to_check instanceof Date)
                    );
                };

                // check if a key exists in an array
                psynet.utils.key_exists_in_array = function (key, arr) {
                    return (arr.indexOf(key) > -1);
                };

                // compute a mean; this is not build-in into Javascript XD
                psynet.utils.mean = function (numbers) {
                    var total = 0, i;
                    for (i = 0; i < numbers.length; i += 1) {
                        total += numbers[i];
                    }
                    return total / numbers.length;
                };

                psynet.waitForEventListener = async function(target, type) {
                    await new Promise((resolve) => {
                       target.addEventListener(type, () => resolve(), {once: true});
                    });
                };

                class PsyNetError extends Error {
                    constructor(message) {
                        super(message);
                        this.name = "PsyNetError"; // (2)
                    }
                }

                psynet.log = {};

                psynet.log.max = 100;
                psynet.log.counter = 0;

                psynet.log.generic = function (msg, level) {
                    if (level !== "error" && level !== "warning" && level !== "info" && level !== "debug") {
                        throw new Error("Invalid log level: " + level);
                    }

                    let time = new Date();
                    console.log("LOG (" + level.toUpperCase() + ") at " + time.toLocaleTimeString()  + ": " + msg);

                    if (level != "debug" && psynet.log.counter < psynet.log.max) {
                        psynet.log.counter += 1;

                        route = (
                            '/log/' + level
                            + "/" + dallinger.identity.participantId
                            + "/" + dallinger.identity.assignmentId
                        );

                        dallinger.post(route, {message: msg});
                    }
                };

                psynet.log.error = function (msg) {
                    var msg_with_browser_info = msg + "\n    " + "Platform: " + platform.toString();
                    psynet.log.generic(msg_with_browser_info, "error");
                };

                psynet.log.warning = function (msg) {
                    psynet.log.generic(msg, "warning")
                };

                psynet.log.warn = psynet.log.warning

                psynet.log.info = function (msg) {
                    psynet.log.generic(msg, "info")
                };

                psynet.log.debug = function (msg) {
                    psynet.log.generic(msg, "debug")
                }

                let Trial = function() {
                    let trial = {
                        state: null,
                        events: {},
                        timers: [],
                        eventLog: [],
                        inProgress: false,
                        stopping: false
                    };

                    trial.reset = function() {
                        trial.state = null;
                        trial.inProgress = false;
                        trial.startTime = null;
                        Object.values(trial.events).forEach((e) => e.reset());
                    };

                    let Event = function(id, spec) {
                        let event = {
                            id: id,
                            toBeTriggered: [],
                            triggerCondition: spec.trigger_condition,
                            delay: spec.delay,
                            once: spec.once,
                            handlers: [],
                            happened: false,
                            message: spec.message,
                            messageColor: spec.message_color,
                            js: spec.js
                        };
                        event.isTriggeredBy = spec.is_triggered_by.map((t) => {
                            let trigger = {
                                delay: t.delay,
                                triggeringEvent: t.triggering_event,
                                fired: false,
                                triggeredEvent: event
                            };
                            trigger.fire = function(info) {
                                trigger.fired = true;
                                trigger.triggeredEvent.checkTriggers(info);
                            };
                            return trigger
                        });

                        event.checkTriggers = function(info) {
                            let allTriggersFired = event.isTriggeredBy.every((trigger) => trigger.fired);
                            if ((event.triggerCondition == "any" || allTriggersFired) && (!(event.once && event.happened))) {
                                trial.setTimer(() => trial.registerEvent(id, {info: info}), event.delay * 1000);
                            }
                        };

                        event.propagateTriggers = function() {
                            event.isTriggeredBy.forEach((trigger) => {
                                let triggeringEvent = trial.events[trigger.triggeringEvent];
                                if (!triggeringEvent) {
                                    triggeringEvent = genericEvent(trigger.triggeringEvent);
                                    trial.events[trigger.triggeringEvent] = triggeringEvent;
                                }

                                triggeringEvent.toBeTriggered.push(trigger);
                            });
                        };

                        event.resetTriggers = function() {
                            event.isTriggeredBy.forEach((trigger) => {
                                trigger.fired = false;
                            });
                        };

                        event.reset = function() {
                            event.happened = false;
                            event.resetTriggers();
                        };

                        event.showMessage = function() {
                            if (event.message !== null) {
                                psynet.trialProgress.setText(event.message, event.messageColor);
                            }
                        };

                        event.runJS = function(info) {
                            if (event.js !== null) {
                                Function("info", unescape(event.js))(info);
                            }
                        };

                        event.runHandlers = async function(info) {
                            let handlers = event.handlers;

                            // Sort in order of decreasing priority
                            handlers.sort((a, b) => - (a.priority - b.priority));

                            for (const handler of handlers) {
                                trial.pendingEventHandlers.add(id);
                                await handler.func(info);
                                trial.pendingEventHandlers.remove(id);
                            }
                        };

                        event.hitTriggers = function(info) {
                            for (const target of event.toBeTriggered) {
                                trial.setTimer(() => target.fire(info), target.delay * 1000);
                            }
                        };

                        return event;
                    };

                    let genericEvent = function(id) {
                        // We use snake_case here to mirror the specification format
                        // that comes from the Python back-end
                        return Event(id, {
                            is_triggered_by: [],
                            trigger_condition: "all",
                            delay: 0.0,
                            once: false
                        });
                    };

                    trial.initEvents = function() {
                        let rawEvents = {{ events | tojson }};
                        Object.entries(rawEvents).forEach(([id, spec]) => trial.events[id] = Event(id, spec));
                        Object.values(trial.events).forEach((event) => event.propagateTriggers());
                    };

                    trial.initEvents()

                    trial.setTimer = function(handler, timeout) {
                        trial.timers.push(setTimeout(handler, timeout));
                    };

                    trial.clearTimers = function() {
                        trial.timers.forEach(timer => clearTimeout(timer));
                    };

                    trial.pendingEventHandlers = (() => {
                        let data = {};
                        return {
                            data: data,

                            add: function(id) {
                                let time = new Date();
                                data[id] = {
                                    timeStarted: time
                                }
                            },

                            remove: function(id) {
                                delete data[id];
                            },

                            waitFor: async function(provided_options) {
                                let options = {
                                    pollInterval: 0.005,
                                    timeOut: 10,
                                    ignore: []
                                };

                                Object.assign(options, provided_options);

                                let timer = 0;

                                function queueIsEmpty() {
                                    let pendingHandlers = Object.keys(data);
                                    let filteredHandlers = pendingHandlers.filter((id) => !options.ignore.includes(id));
                                    return filteredHandlers.length == 0;
                                }

                                function checkQueue() {
                                    return new Promise((resolve, reject) => {
                                        let poller = setInterval(() => {
                                            if (queueIsEmpty()) {
                                                clearInterval(poller);
                                                resolve();
                                            } else {
                                                timer += options.pollInterval;
                                                if (timer >= options.timeOut) {
                                                    reject();
                                                    clearInterval(poller);
                                                    throw new Error("Timed out when waiting for event handlers to complete.");
                                                }
                                            }
                                        }, options.pollInterval);
                                    });
                                }

                                await checkQueue();
                            }
                        };
                    })();

                    trial.logEvent = function(id, info) {
                        let time = new Date();
                        trial.eventLog.push({
                            eventType: id,
                            localTime: time,
                            info: info
                        });
                        psynet.log.debug(id);
                    }

                    trial.registerEvent = async function(id, providedOptions) {
                        let options = {
                            info: null,
                            once: false
                        };
                        Object.assign(options, providedOptions);

                        let event = trial.events[id];
                        if (event !== undefined && event.happened && options.once) {
                            return;
                        }

                        trial.state = id;
                        trial.logEvent(id, options.info);

                        if (event !== undefined) {
                            event.happened = true;
                            event.showMessage();
                            event.runJS(options.info);
                            await event.runHandlers(options.info);
                            event.hitTriggers(options.info);
                        }
                    };

                    trial.onEvent = function(id, handler, provided_options) {
                        // Higher priority values are executed first
                        let options = {
                            priority: 0.0
                        };
                        Object.assign(options, provided_options);

                        let event = trial.events[id]
                        if (event === undefined) {
                            event = genericEvent(id);
                            trial.events[id] = event;
                        }
                        event.handlers.push({
                            func: handler,
                            priority: options.priority
                        });
                    };

                    trial.getGlobalTime = function() {
                        return psynet.media.audio_context.currentTime;
                    };

                    trial.listEvents = function() {
                        return Object.keys(trial.events);
                    };

                    trial.init = async function() {
                        // Should only be called once, on page load
                        await trial.registerEvent("trialConstruct");
                    };

                    trial.stop = async function() {
                    /**
                     * Can be called manually to stop the trial.
                     * Is idempotent (you can call it multiple times
                     * with no bad side effects).
                     */
                        if (trial.inProgress && !trial.stopping) {
                            trial.stopping = true;
                            trial.clearTimers();
                            trial.inProgress = false;
                            await this.pendingEventHandlers.waitFor();
                            await trial.registerEvent("trialStop");
                            trial.reset();
                            trial.stopping = false;
                        }
                    };

                    trial.restart = async function(providedOptions) {
                        // Can be called manually at an arbitrary point to restart the trial
                        let options = {
                            from: "trialPrepare"
                        };
                        Object.assign(options, providedOptions);

                        await trial.stop();
                        trial.reset();
                        trial.inProgress = true;
                        await trial.registerEvent(options.from);
                    }

                    return trial;
                }

                psynet.trial = Trial();

                psynet.trial.onEvent("trialConstruct", async function() {
                    await psynet.media.init();
                    $(".wait-for-media-load").removeAttr("disabled");
                });

                psynet.trial.onEvent("trialPrepare", function() {
                    psynet.trial.inProgress = true;
                });

                psynet.trial.onEvent("trialFinished", function() {
                    psynet.trial.inProgress = false;
                });

                psynet.trial.onEvent("trialStopped", function() {
                    psynet.trial.inProgress = false;
                });

                psynet.submit = {
                    enable: () => $(".submit").removeAttr("disabled"),
                    disable: () => $(".submit").attr("disabled", "disabled")
                };

                psynet.response = {
                    staged: {
                        raw_answer: null,
                        metadata: undefined,
                        blobs: undefined
                    },
                    enable: () => $(".response").removeAttr("disabled"),
                    disable: () => $(".response").attr("disabled", "disabled")
                };

                psynet.trial.onEvent("responseEnable", psynet.response.enable);
                psynet.trial.onEvent("submitEnable", psynet.submit.enable);

                psynet.media.types = ["audio", "image", "video"];
                psynet.media.data = {};

                psynet.media.sounds = [];

                psynet.media.loaded = false;

                psynet.media.download_progress = {
                    by_file: {}
                };

                psynet.media.types.forEach(function (media_type) {
                    psynet.media.download_progress.by_file[media_type] = {};
                });

                psynet.media.download_progress.set = function (media_type, file_id, value) {
                    psynet.media.download_progress.by_file[media_type][file_id] = value;
                    psynet.media.download_progress.update_display();
                };

                psynet.media.download_progress.get_total = function () {
                    let res = [];
                    Object
                        .values(psynet.media.download_progress.by_file)
                        .forEach(function (processes) {
                            Object.values(processes).forEach(function (i) {
                                res.push(i)
                            });
                        });
                    return psynet.utils.mean(res);
                };

                psynet.media.download_progress.bar = function () {
                    return document.getElementById("media_download_progress_bar")
                };

                psynet.media.download_progress.update_display = function () {
                    let bar = psynet.media.download_progress.bar();
                    if (bar !== null) {
                        var progress = psynet.media.download_progress.get_total();
                        bar.style.width = Math.round(progress) + "%";
                        if (progress === 100) {
                            // You could do something here once loading is complete,
                            // e.g. delete progress bar text
                        }
                    }
                };

                // The last thing we expect of the user is that the resources, that need to be loaded, are dumped as a json:
                // For example here, we request a batch file that contains three files and we request a single file
                // As we can see each file has a ID and a url where the file is stored
                {{ define_media_requests }}

                // psynet.media.requests = {
                //     "audio": {
                //         "batch": {
                //             "url": "file_concatenated.mp3",
                //             "ids": ["funk_game_loop", "honey_bee", "there_it_is"],
                //             "type": "batch"
                //         },
                //         "bier": "bier.wav"
                //     }
                // };

                psynet.media.stop_all_audio = function() {
                    if (psynet.audio) {
                        Object.values(psynet.audio).forEach(function(x) {
                            x.stop();
                        });
                    }
                }

                psynet.media.init_audio_context = function () {
                    let context = null;
                    if ("webkitAudioContext" in window) context = new webkitAudioContext();
                    if ("AudioContext" in window) context = new AudioContext();
                    if (!context) {
                        throw Error("ERROR: No AudioContext available. Try Chrome, Safari or Firefox Nightly.");
                    }
                    if (context.state == "suspended") {
                        context.resume();
                    }
                    psynet.media.audio_context = context;
                };

                let askUserToResume = function() {
                    return new Promise((resolve) => {
                        let resumeModal = $("#resume_modal");
                        let resumeButton = $("#resume_button");
                        resumeModal.css("display", "block");
                        resumeButton.click(async function() {
                            resumeModal.css("display", "none");
                            await psynet.media.init();
                            resolve();
                        });
                    });
                };

                psynet.media.init = async function () {
                    psynet.media.init_audio_context();

                    if (psynet.media.audio_context.state == "suspended") {
                        psynet.log.info(
                            "Audio context is suspended, and can only be resumed " +
                            "after a user interaction. Waiting for the participant to click 'Resume'."
                        );
                        await askUserToResume();
                        psynet.media.init_audio_context();
                    }
                    let requests = psynet.media.requests;
                    let media_types = Object.keys(requests);
                    await Promise.all(
                        media_types.map((x) => processRequests(x, requests[x]))
                    );
                };

                let init_media_type = function (media_type) {
                    let x = {};
                    psynet.media.data[media_type] = x;
                    psynet[media_type] = x;
                };

                let init_stimulus = function (id, media_type) {
                    psynet.media.data[media_type][id] = {
                        loaded: false
                    };
                };

                let processRequests = function (media_type, requests) {
                    init_media_type(media_type);
                    check_requests(requests);

                    return Promise.all(
                        Object.keys(requests).map(function (id) {
                            let value = requests[id];
                            if (is_batch(value)) {
                                return preload_batch(id, value, media_type);
                            } else {
                                let url = value;
                                return preload_stimulus(id, url, media_type);
                            }
                        })
                    );
                };

                let is_batch = function (x) {
                    return psynet.utils.is_dict(x)
                };

                let preload_batch = function (batch_id, batch, media_type) {
                    let url = batch.url;
                    let args = {
                        batch_id: batch_id,
                        stimulus_ids: batch.ids,
                        media_type: media_type,
                        file_id: batch_id
                    };
                    args.stimulus_ids.forEach(function (id) {
                        init_stimulus(id, media_type);
                    });

                    return create_request(url, media_type, process_media_batch[media_type], args);
                };

                let preload_stimulus = function (stimulus_id, url, media_type) {
                    let args = {
                        stimulus_id: stimulus_id,
                        media_type: media_type,
                        file_id: stimulus_id
                    };
                    init_stimulus(stimulus_id, media_type);
                    return create_request(url, media_type, create_media_from_buffer[media_type], args);
                };

                function report_request_error(url, status) {
                    let msg;
                    if (status === 404) {
                        msg = "Failed to load media asset at " + url + " (404, file not found).";
                    } else {
                        msg = "Failed to load media asset at " + url + " (error code = " + status + ")."
                    }
                    throw Error(msg);
                }

                async function create_request(url, media_type, callback_function, args) {
                    let request = new XMLHttpRequest();
                    request.open("GET", url, true);

                    if (media_type == "audio") {
                        request.responseType = "arraybuffer";
                    } else if (media_type == "image" || media_type == "video") {
                        request.responseType = "blob";
                    } else {
                        throw Error("Unsupported media type: " + media_type);
                    }

                    request.onprogress = function (e) {
                        psynet.media.download_progress.set(args["media_type"], args["file_id"], e.loaded * 100 / e.total);
                    };

                    return new Promise((resolve) => {
                        request.onload = async function () {
                            if (request.status === 200) {
                                await callback_function(request.response, args);
                                resolve();
                            } else {
                                report_request_error(url, request.status);
                            }
                        };

                        request.send();
                    });
                }

                check_requests = function (requests) {
                    // - Checks for missing URLs in batches.
                    // - Checks for duplicated IDs
                    let ids = [];

                    let log = function (id) {
                        var value = requests[id];
                        if (psynet.utils.is_dict(value)) {
                            log_batch(value);
                        } else {
                            log_stimulus(id);
                        }
                    };

                    let log_stimulus = function (id) {
                        if (psynet.utils.key_exists_in_array(id, ids)) {
                            throw Error("The ID you specified `" + id + "` already exists! IDs must be unique!");
                        }
                        ids.push(id);
                    };

                    let log_batch = function (batch) {
                        if (!("url" in batch)) {
                            throw Error('Each batch object must contain a "url" attribute.');
                        }
                        if (!("ids" in batch)) {
                            throw Error('Each batch object must contain an "ids" attribute specifying its constituent stimuli.');
                        }
                        let stimulus_ids = batch["ids"];
                        stimulus_ids.forEach(log_stimulus);
                    };

                    Object.keys(requests).forEach(log);
                };

                let create_audio_stimulus = function(data, stimulus_id, handler) {
                    psynet.log.debug("Decoding sound " + stimulus_id + "...");

                    return new Promise((resolve) => { psynet.media.audio_context.decodeAudioData(data, function (buffer) {
                        psynet.log.debug("Sound " + stimulus_id + " decoded.");

                        let out = psynet.media.data.audio[stimulus_id];
                        out.buffer = buffer;

                        out.play = function (provided_options) {
                            let options = {
                                fade_in: 0.0,
                                fade_out: 0.0,
                                start_delay: 0.01,
                                gain: 1,
                                loop: false,
                                start: null,
                                end: null
                            };

                            Object.assign(options, provided_options);

                            const start = (options.start === null) ? 0.0 : options.start;
                            const duration = (options.end === null) ? undefined : options.end - options.start;

                            let sound = {
                                source: psynet.media.audio_context.createBufferSource(),
                                gain_node: psynet.media.audio_context.createGain(),
                                start_time: psynet.media.audio_context.currentTime + options.start_delay,
                                options: options,
                                manually_stopped: false,
                                duration: (duration === undefined) ? buffer.duration : duration,
                                stimulus_id: stimulus_id,
                                on_end: null
                            };

                            sound.source.buffer = buffer;

                            sound.source.connect(sound.gain_node);
                            sound.gain_node.connect(psynet.media.audio_context.destination);

                            sound.gain_node.gain.setValueAtTime(
                                0.001,
                                sound.start_time
                            );

                            sound.source.start(sound.start_time, start, duration);

                            if (options.gain > 1e-10) {
                                sound.gain_node.gain.exponentialRampToValueAtTime(
                                    options.gain,
                                    psynet.media.audio_context.currentTime + options.start_delay + options.fade_in
                                );
                            }

                            let stopTimer = setTimeout(
                                () => sound.stop({fade_out: options.fade_out, manual: false}),
                                1000 * (options.start_delay + sound.duration - options.fade_out)
                            );

                            sound.stop = function (provided_options) {
                                let options = {
                                    fade_out: sound.options.fade_out,
                                    manual: true
                                };

                                Object.assign(options, provided_options);

                                clearTimeout(stopTimer);

                                psynet.log.debug("Stopping audio " + sound.stimulus_id + ".");

                                sound.manually_stopped = options.manual;

                                let gain_now = sound.gain_node.gain.value;
                                let time_now = psynet.media.audio_context.currentTime;

                                if (sound.gain_node.gain.value > 0.001) {
                                    sound.gain_node.gain.setValueAtTime(gain_now, time_now);
                                    sound.gain_node.gain.exponentialRampToValueAtTime(0.001, time_now + options.fade_out);
                                }

                                return new Promise((resolve) => {
                                    setTimeout(() => {
                                        sound.source.stop();
                                        resolve();
                                    }, options.fade_out * 1000);
                                });
                            }

                            sound.source.addEventListener("ended", function () {
                                clearTimeout(stopTimer);
                                psynet.log.debug("Finished sound with ID = " + sound.stimulus_id);
                                psynet.media.sounds = psynet.media.sounds.filter(s => s !== sound);
                                if (sound.options.loop && !sound.manually_stopped) {
                                    psynet.log.debug("Looping sound with ID = " + out.stimulus_id);
                                    out.play(sound.options);
                                }
                            });

                            psynet.media.sounds.push(sound);
                            return sound;
                        };

                        out.stop = function (options) {
                            psynet.media.sounds.forEach(function(s) {
                                if (s.stimulus_id == stimulus_id) {
                                    s.stop(options);
                                }
                            });
                            return this
                        };

                        out.loaded = true;

                        resolve();
                    })});
                };

                psynet.media.blob_to_array_buffer = async function(blob) {
                    let buffer = await new Response(blob).arrayBuffer();
                    return buffer;
                }

                // Used to add extra stimuli that aren't loaded as part of the initial media load
                // (needs refactoring in a general cross-media way)
                psynet.media.add_extra_audio_stimulus = async function(buffer, stimulus_id) {
                    init_stimulus(stimulus_id, "audio");
                    await create_audio_stimulus(buffer, stimulus_id, () => Promise.resolve());
                }

                let create_media_from_buffer = {};
                create_media_from_buffer.audio = function (data, args) {
                    psynet.media.download_progress.set(args.media_type, args.file_id, 100);
                    return create_audio_stimulus(data, args.stimulus_id);
                };

                let get_image_metadata_from_url = function(url) {
                    return new Promise((resolve, reject) => {
                        let img = new Image();
                        img.onload = () => resolve({
                            width: img.width,
                            height: img.height
                        });
                        img.onerror = () => reject();
                        img.src = url;
                    });
                };

                create_media_from_buffer.image = async function (data, args) {
                    let stimulus_id = args["stimulus_id"];
                    let media_type = args["media_type"];
                    let file_id = args["file_id"];
                    let url = URL.createObjectURL(data);
                    let metadata = await get_image_metadata_from_url(url);

                    let out = psynet.media.data[media_type][stimulus_id];
                    out.url = url;
                    out.width = metadata.width;
                    out.height = metadata.height;
                    out.aspect_ratio = out.width / out.height;
                    out.loaded = true;

                    psynet.media.download_progress.set(media_type, file_id, 100);
                    return true;
                }

                create_media_from_buffer.video = function (data, args) {
                    let stimulus_id = args["stimulus_id"];
                    let media_type = args["media_type"];
                    let file_id = args["file_id"];

                    let player = document.getElementById(stimulus_id);
                    if (player != null) {
                        psynet.log.debug(
                            "Associating video '" + stimulus_id
                            + "' with the player of the same name.'"
                        );
                        player.src = URL.createObjectURL(data);
                        player.classList.remove("loader");
                        player.load();
                    }

                    let out = psynet.media.data[media_type][stimulus_id];
                    out.player = player;
                    out.loaded = true;

                    psynet.media.download_progress.set(media_type, file_id, 100);
                    return true;
                };

                let process_media_batch = {};

                process_media_batch.audio = function (data, args) { //, ids,) {
                    let stimulus_ids = args["stimulus_ids"];
                    let media_type = args["media_type"];
                    let file_id = args["file_id"];

                    function extract_buffer(src, start, length) {
                        // This function is used to find the start and end of each file
                        let dstU8 = new Uint8Array(length);
                        let srcU8 = new Uint8Array(src, start, length);
                        dstU8.set(srcU8);
                        return dstU8;
                    }

                    let num_files = current_file = 0;
                    psynet.log.debug('Unpacking the audio batch "' + file_id + '".');
                    let bb = new DataView(data);
                    let offset = 0;
                    let promises = [];

                    while (offset < bb.byteLength) {
                        let stimulus_id = stimulus_ids[num_files];
                        let length = bb.getUint32(offset, true);
                        offset += 4;
                        let sound = extract_buffer(data, offset, length);
                        offset += length;
                        num_files++;

                        if (num_files > stimulus_ids.length) {
                            throw Error(
                                "Too many stimuli found in batch file (" +
                                "expected " + stimulus_ids.length +
                                ", got at least" + num_files + ")."
                            );
                        }

                        args = {
                            stimulus_id: stimulus_id,
                            media_type: media_type,
                            file_id: file_id
                        };

                        promises.push(create_media_from_buffer.audio(sound.buffer, args));
                    }
                    if (num_files < stimulus_ids.length) {
                        throw Error(
                            "Too few stimuli found in batch file (" +
                            "expected " + stimulus_ids.length +
                            ", got " + num_files + ")."
                        );
                    }
                    return Promise.all(promises);
                };

                let check_participant_id = function () {
                    if (dallinger.identity.participantId === undefined) {
                        alert(
                            "Your participant ID is undefined, perhaps because you " +
                            "switched browsers during the test. " +
                            "Unfortunately this behaviour is not currently supported."
                        );
                        throw console.error("Undefined participant ID.");
                    }
                };

                let init_modal = function () {
                    let modal = document.getElementById("help_modal");
                    let help_btn = document.getElementById("help_button");
                    let span = document.getElementsByClassName("close")[0];

                    if (modal !== null) {
                        help_btn.onclick = function () {
                            modal.style.display = "block";
                        };

                        span.onclick = function () {
                            modal.style.display = "none";
                        };

                        window.onclick = function (event) {
                            if (event.target === modal) {
                                modal.style.display = "none";
                            }
                        }
                    }
                };

                psynet.estimate_download_speed = function() {
                    // Returns estimated download speed in megabits/second
                    // (at the time of writing, this is capped at 10).
                    let connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                    return connection.downlink
                }

                psynet.page_loaded = false;

                let waitForPageLoad = function() {
                    return new Promise(resolve => {
                        window.addEventListener("load", () => resolve());
                    });
                };

                psynet.init_page = async function () {
                    console.log("Initialising page...");

                    psynet.register_error_handler();
                    check_participant_id();
                    init_modal();

                    psynet.response.disable();
                    psynet.submit.disable();
                    $(".wait-for-media-load").attr("disabled", "disabled");

                    await waitForPageLoad();

                    psynet.page_load_time = new Date();
                    psynet.page_loaded = true;

                    setTimeout(() => psynet.trial.init(), 25);
                };

                psynet.register_error_handler = function () {
                    window.onerror = function (msg, url, line, col, error) {
                        psynet.log.error(error.stack);
                    }
                };

                psynet.next_page = function (raw_answer, metadata, blobs) {
                    // Arguments default to psynet.response.staged if they
                    // are not provided explicitly.
                    if (raw_answer === undefined) {
                        raw_answer = psynet.response.staged.raw_answer;
                    }
                    if (metadata === undefined) {
                        metadata = psynet.response.staged.metadata;
                    }
                    if (blobs === undefined) {
                        blobs = psynet.response.staged.blobs;
                    }
                    submit_generic_response(raw_answer, metadata, blobs, on_success_response, on_error_response);
                };

                let on_success_response = function (request) {
                    let response = JSON.parse(request.response);
                    if (response.submission === "approved") {
                        psynet.log.debug("Response received successfully.");
                        let should_refresh_page = !(
                            response.page.attributes && psynet.page.attributes &&
                            response.page.attributes.session_id == psynet.page.attributes.session_id
                        );
                        if (should_refresh_page) {
                            dallinger.goToPage("timeline/" + dallinger.identity.participantId + "/" + dallinger.identity.assignmentId);
                        } else {
                            psynet.page = response.page;
                            psynet.register_event("page_updated");
                        }
                    } else if (response.submission === "rejected") {
                        psynet.log.debug("Response rejected.");
                        alert(response.message);
                        psynet.response.enable();
                        psynet.submit.enable();
                    } else {
                        throw Error("Received a malformed response.");
                    }
                };

                on_page_updated = function(event) {
                    console.log("Dispatched 'on_page_updated' event. Sending data to Unity:\nattributes:" + psynet.page.attributes + "\ncontents:" + psynet.page.contents);
                    unityInstance.SendMessage(
                        "PsynetObj",
                        "GetData",
                        JSON.stringify({
                            attributes: psynet.page.attributes,
                            contents: psynet.page.contents,
                        })
                    );
                };

                let on_error_response = function (request) {
                    dallinger.error({
                        "data": {
                            "participant_id": dallinger.identity.participantId
                        }
                    });
                };

                let add_blobs = function (form_data, blobs) {
                    for (let [key, value] of Object.entries(blobs)) {
                        if (key === "json") {
                            throw Error("Blobs may not be named 'json'.");
                        }
                        form_data.append(key, value);
                    }
                };

                let prepare_json_submission = function (raw_answer, metadata) {
                    var current_time = new Date();

                    var all_metadata = {
                        "time_taken": (current_time - psynet.page_load_time) / 1000,
                        "platform": platform.toString(),
                        "download_speed_megabits_per_sec": psynet.estimate_download_speed(),
                        "event_log": psynet.trial.eventLog
                    };

                    if (metadata !== undefined) {
                        for (var x in metadata) {
                            all_metadata[x] = metadata[x];
                        }
                    }

                    return JSON.stringify({
                        "participant_id": dallinger.identity.participantId,
                        "page_uuid": page_uuid,
                        "raw_answer": raw_answer,
                        "metadata": all_metadata
                    });
                };

                let submit_generic_response = function (raw_answer, metadata, blobs, on_success_response, on_error_response) {
                    // raw_answer - an arbitrary Javascript object (not necessarily an Object) to be sent to JSON
                    // blobs - optional Object, each attribute should be a blob to upload.
                    //       - Note that 'json' is not a permitted name for an attribute
                    $( " .response, .submit " ).prop("disabled", true);

                    json = prepare_json_submission(raw_answer, metadata);

                    var formData = new FormData();
                    formData.append("json", json);

                    if (blobs !== undefined) {
                        add_blobs(formData, blobs);
                    }

                    var request = new XMLHttpRequest();

                    request.onreadystatechange = function () {
                        if (request.readyState === 4) {
                            if (request.status === 200) {
                                psynet.log.debug("Response was successfully received.");
                                on_success_response(request);
                            } else {
                                psynet.log.debug("Something went wrong.");
                                on_error_response(request);
                            }
                        }
                    };
                    request.open("POST", "/response");
                    request.send(formData);
                };

                psynet.trialProgress = (() => {
                    let config = {{ trial_progress_display_config | tojson }};
                    let opacities = {light: 0.25, medium: 0.6, dark: 1.0};

                    let init = function() {
                        config.stages.forEach((stage) => stage.html = {});
                        config.stages.forEach((stage) => {
                            stage.html.past = addBarSegment(stage.color, opacities.dark);
                        });
                        config.stages.forEach((stage) => {
                            stage.html.future = addBarSegment(stage.color, opacities.light);
                        });
                        config.stages.forEach((stage) => {
                            stage.update = function(elapsed) {
                                let proportionOfStageComplete = bound((elapsed - stage.time[0]) / stage.duration, 0, 1);
                                let proportionOfBarComplete = (proportionOfStageComplete * stage.duration) / config.duration;
                                stage.html.past.setWidth(100 * proportionOfBarComplete);
                                let proportionOfStageIncomplete = 1 - proportionOfStageComplete;
                                let proportionOfBarIncomplete = (proportionOfStageIncomplete * stage.duration) / config.duration
                                stage.html.future.setWidth(100 * proportionOfBarIncomplete);
                                if (proportionOfStageComplete > 0) {
                                    if (stage.persistent || proportionOfStageComplete < 1) {
                                        activeStage = stage;
                                    } else {
                                        activeStage = null;
                                    }
                                }
                            };
                        });
                        setInterval(update, 5);
                    };

                    let bound = function(x, min, max) {
                        return Math.max(min, Math.min(x, max));
                    };

                    let addBarSegment = function (color, opacity) {
                        let bar = $("#trial-progress-bar");
                        let segment = $("<div/>", {
                            "class": "progress-bar trial-progress-bar-segment",
                            role: "progressbar",
                            style: "width: 0%; opacity: " + opacity + "; background-color: " + color + ";",
                            "aria-valuenow": "0",
                            "aria-valuemin": "0",
                            "aria-valuemax": "100"
                        });
                        bar.append(segment);
                        segment.setWidth = function (percent) {
                            segment.css("width", percent + "%");
                            segment.attr("aria-valuenow", percent);
                        };
                        return segment;
                    };

                    let activeStage = config.stages[0];
                    let startTime = null;

                    let start = function () {
                        startTime = psynet.trial.getGlobalTime();
                    };

                    let stop = function() {
                        startTime = null;
                        activeStage = null;
                    };

                    let setText = function(content, color) {
                        if (content == "") {
                            resetText();
                        } else {
                            let text = $("#trial-progress-caption-contents");
                            text.text(content);
                            if (color) {
                                text.css("color", color);
                            }
                        }
                    };

                    let resetText = function() {
                        let text = $("#trial-progress-caption-contents");
                        text.html("&nbsp;");
                    };

                    let update = function() {
                        let elapsed = startTime !== null ? psynet.trial.getGlobalTime() - startTime : 0.0
                        config.stages.forEach((s) => s.update(elapsed));
                        if (config.stages.length > 0) {
                            if (activeStage) {
                                setText(activeStage.caption, activeStage.color);
                            } else {
                                resetText();
                            }
                        }
                    };

                    psynet.trial.onEvent("trialConstruct", init, {priority: -1000});
                    psynet.trial.onEvent(config.start, start);
                    psynet.trial.onEvent("trialStopped", stop);
                    psynet.trial.onEvent("pageUpdated", on_page_updated);

                    return {
                        setText: setText,
                        start: start,
                        stop: stop
                    };
                })();

                psynet.audio = psynet.media.data.audio;
                psynet.image = psynet.media.data.image;
                psynet.video = psynet.media.data.video;

                return psynet
            }()
        )
    </script>

{% endblock %}

{% block libs %}
    {{ super() }}
    <script src="https://cdnjs.cloudflare.com/ajax/libs/platform/1.3.5/platform.min.js" type="text/javascript"></script>
{% endblock %}

{% block scripts %}
    {{ super() }}

    <script>
        psynet.init_page();
    </script>

    {% for x in scripts %}
        <script>
            {{ x }}
        </script>
    {% endfor %}

{% endblock %}
