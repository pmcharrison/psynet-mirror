{% macro null(config) %}
    <script>
        on_next_button = function() {
            $(this).prop('disabled', true);
            if (typeof retrieve_response == "undefined") {
                psynet.next_page();
            } else {
                response = retrieve_response();
                psynet.next_page(
                    response.raw_answer,
                    response.metadata,
                    response.blobs
                );
            }
        }
    </script>

    <button type="button" id="next_button" class="btn btn-primary btn-lg submit" onclick="on_next_button();">
        Next
    </button>
{% endmacro %}

{% macro reset_button(config, input_type) %}
    <script>
        {% if config.show_reset_button == "on_selection" %}
        $("#reset_button").css({"display": "block"});
        {% endif %}
        on_reset_button = function(input_type) {
            $('input[type={{ input_type }}]').attr('checked', false);
            {% if config.show_reset_button == "on_selection" %}
            $("#reset_button").css({"display": "none"});
            {% endif %}
            $("#reset_button").prop('disabled', true);
        }

        $('input[type={{ input_type }}]').click(function() {
            {% if config.show_reset_button == "on_selection" %}
            $("#reset_button").css({"display": "block"});
            {% endif %}
            if (!$('input[type={{ input_type }}]').is(':checked'))
            {
                $("#reset_button").prop('disabled', true);
            } else {
                $("#reset_button").prop('disabled', false);
            }
        });
    </script>

    <button type="button" id="reset_button" class="btn btn-primary btn-lg" style="{% if config.show_reset_button == 'on_selection' %}display: none{% endif %}; margin-right: 30px;" onclick="on_reset_button();" disabled>
        Reset
    </button>
    {% endmacro %}

{% macro push_button(config) %}
    <button
        type="button"
        class="btn push_button btn-primary response {% if config.timed == true %} timed {% else %} submit {% endif %}"
        id="{{ config.id }}"
        onclick="clicked_button(this, this.id);"
        style="{{ config.style }}"
    >
        {% autoescape off %}
        {{ config.label }}
        {% endautoescape %}
    </button>
{% endmacro %}

{% macro push_buttons(config) %}
    <style>
        .push-button-container {
            display: {% if config.arrange_vertically %}grid{% else %}flex{% endif %};
            flex-wrap: wrap;
            justify-content: center;
            max-height: 420px;
            overflow-y: auto;
        }
    </style>

    <div class="push-button-container">
        {% for button in config.push_buttons %}
            {{ push_button(button) }}
        {% endfor %}
    </div>

    {% if config.timed == true %}
        <p class="vspace"></p>
        {{ null(config) }}
    {% endif %}

    <script>
        let buttonTimers = {};

        clicked_button = function(button, id) {
            psynet.trial.registerEvent("pushButtonClicked", {info: {buttonId: id}});

            {% if config.timed == true %}
                let buttonHighlightDuration = {{ config.button_highlight_duration }};
                if (buttonTimers[id] !== undefined) {
                    clearTimeout(buttonTimers[id]);
                }
                highlightButton(button);
                buttonTimers[id] = setTimeout(unhighlightButton, buttonHighlightDuration * 1000, button);
            {% else %}
                psynet.response.disable();
                psynet.submit.disable();
                psynet.next_page(id);
            {% endif %}
        }

        highlightButton = function(button) {
            button.classList.remove("btn-primary");
            button.classList.add("btn-success");
        }

        unhighlightButton = function(button) {
            button.classList.add("btn-primary");
            button.classList.remove("btn-success");
        }
    </script>
{% endmacro %}

{% macro checkbox(config) %}
    <label style="margin-left: 15px; cursor: pointer;">
        <input
            type="checkbox"
            id="{{ config.id }}"
            name="{{ config.name }}"
            class="response"
            style="cursor: pointer;"
        />
        <span>{{ config.label }}</span>
    </label>
{% endmacro %}

{% macro checkboxes(config) %}
    <style>
        .control-container {
            display: {% if config.arrange_vertically %}grid{% else %}flex{% endif %};
            flex-wrap: wrap;
            justify-content: center;
            max-height: 420px;
            overflow-y: auto;
        }
    </style>
    <div class="control-container">
        {% for _checkbox in config.checkboxes %}
            {{ checkbox(_checkbox) }}
        {% endfor %}
    </div>
    <p class="vspace"></p>
    <div style="justify-content: center; display: flex; margin-top">
        {% if config.show_reset_button != "never" %}
        {{ reset_button(config, "checkbox") }}
        {% endif %}
        {{ null(config) }}
    </div>
    <script>
        clicked_button = function(id) {
            psynet.response.disable();
            psynet.submit.disable();
            psynet.next_page(id);
        }

        retrieve_response = function() {
            let elements = document.getElementsByName('{{ config.name }}')
            checked_values = Array.from(elements).map(function(element, i) {
                if (element.checked) {return element.id}
            }).filter(function (element) {
              return element != null;
            });
            return {
                raw_answer: checked_values
            }
        }
    </script>
{% endmacro %}

{% macro radiobutton(config) %}
    <label style="margin-left: 15px;">
        <input
            type="radio"
            id="{{ config.id }}"
            name="{{ config.name }}"
            class="response"
            style="{{ config.style }}"
        />
        <span style="{{ config.style }}">{{ config.label }}</span>
    </label>
{% endmacro %}

{% macro radiobuttons(config) %}
    <style>
        .control-container {
            display: {% if config.arrange_vertically %}grid{% else %}flex{% endif %};
            flex-wrap: wrap;
            justify-content: center;
            max-height: 420px;
            overflow-y: auto;
        }
    </style>
    <div class="control-container">
        {% for button in config.radiobuttons %}
            {{ radiobutton(button) }}
        {% endfor %}
    </div>
    <p class="vspace"></p>
    <div style="justify-content: center; display: flex; margin-top">
        {% if config.show_reset_button != "never" %}
        {{ reset_button(config, "radio") }}
        {% endif %}
        {{ null(config) }}
    </div>
    <script>
        clicked_button = function(id) {
            psynet.response.disable();
            psynet.submit.disable();
            psynet.next_page(id);
        }

        retrieve_response = function() {
            let element = document.querySelector('input[name="{{ config.name }}"]:checked')

            return {
                raw_answer: (element != null) ? element.id : null
            }
        }
    </script>
{% endmacro %}

{% macro dropdown_option(config) %}
    <option value="{{ config.value }}">{{ config.text }}</option>
{% endmacro %}

{% macro dropdown(config) %}
    <style>
        .dropdown-container {
            margin: 0 auto;
            width: fit-content;
        }
    </style>
    <div class="dropdown-container">
        <select id="{{ config.name }}" class="form-control response" style="cursor: pointer;" name="{{ config.name }}">
            <option disabled selected value>{{ config.default_text }}</option>
            {% for option in config.dropdown %}
                {{ dropdown_option(option) }}
            {% endfor %}
        </select>
    </div>
    <p class="vspace"></p>
    <div style="justify-content: center; display: flex; margin-top">
        {{ null(config) }}
    </div>
    <script>
        clicked_button = function(id) {
            psynet.response.disable();
            psynet.submit.disable();
            psynet.next_page(id);
        }

        retrieve_response = function() {
            let element = document.getElementById("{{ config.name }}");
            return {
                raw_answer: (element != null) ? element.value : null
            }
        }
    </script>
{% endmacro %}


{% macro audio_slider(config) %}
    {{ slider(config) }}

    <script>
        {% autoescape off %}
        var sound_locations = {{ config.js_vars.sound_locations }};
        var autoplay = {{ config.js_vars.autoplay | lower }};
        {% endautoescape %}

        // Overwrites corresponding method in slider-page.html
        slider.update_log = function() {
            slider.log.push({
                'time': new Date(),
                'value': slider.value,
                'audio': slider.audio
            })
        }

        find_closest_audio = function (slider) {
            var locations = Object.values(sound_locations);
            var nearest = psynet.utils.closest(parseFloat(slider.value), locations);
            var selected_audio = Object.keys(sound_locations)[nearest.index];
            return selected_audio
        };

        play_sound = function () {
            var id = slider.audio;
            var sound = psynet.audio[id];

            if (!sound.playing) {
                psynet.media.stop_all_audio();
                psynet.log.debug('Playing sound with ID = ' + id);
                sound.play();
            }
        };

        on_slider_event = function (event_type) {
            slider.audio = find_closest_audio(slider);
            if (event_type == "initialise") {
                if (autoplay) {
                    play_sound();
                }
            } else if (event_type == "slider_changed") {
                play_sound();
            }
        };
    </script>
{% endmacro %}


{% macro color_slider(config) %}
    <style>
        .main-body {
            background-color: white;
            padding: 30px;
        }
    </style>

    {{ slider(config) }}

    {% for color, value in config.hidden_inputs.items() %}
        <input type="hidden" value="{{ value }}" id="{{ color }}">
    {% endfor %}

    <script>
        function pad(n) {
            return (n.length < 2) ? "0" + n : n;
        }

        // Set the color
        on_slider_event = function (event_type) {
            psynet.log.debug("Updating slider background");
            var r_hex = parseInt(document.getElementById('red').value, 10).toString(16),
                g_hex = parseInt(document.getElementById('green').value, 10).toString(16),
                b_hex = parseInt(document.getElementById('blue').value, 10).toString(16),
                hex = "#" + pad(r_hex) + pad(g_hex) + pad(b_hex);
            document.body.style.backgroundColor = hex;
        };

        document.addEventListener("load", on_slider_event);
    </script>
{% endmacro %}


{% macro slider(config) %}
    <style>
        #{{ config.slider_id }} {
            width: 100%;
            {% if config.reverse_scale == true %} direction: rtl; {% endif %}
        }
        .slider-range {
            cursor: pointer;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            border: 1px solid #000000;
            height: 36px;
            background-color: #efefef;
            border: 11px solid #b2b2b2;
            border-radius: 5px;
            {% if config.directional == false %}
            margin-top: -8px;
            {% endif %}
            cursor: pointer;
        }
        {% if config.directional == false %}
        input[type=range]::-webkit-slider-runnable-track {
              background: #000000;
              border: 1px solid #b2b2b2;
              background-color: #efefef;
              border-radius: 5px;
              width: 100%;
              height: 8px;
            }
        {% endif %}
    </style>

    <input
        type="range"
        id="{{ config.slider_id }}"
        class="wait-for-media-load slider-range form-control-range{% if not config.directional %} slider-non-directional{% endif %}"
        min="{{ config.min_value }}"
        max="{{ config.max_value + 0.0001 * config.step_size }}"
        step="{{ config.step_size }}"
        value="{{ config.start_value }}">
    <p class="vspace"></p>

    {{ null(config) }}

    <script>
        {% autoescape off %}
        var snap_values = {% if config.js_vars.snap_values is none %}null{% else %}{{ config.js_vars.snap_values }}{% endif %};
        var minimal_interactions = {% if config.js_vars.minimal_interactions is none %}null{% else %}{{ config.js_vars.minimal_interactions }}{% endif %};
        var continuous_updates = {% if config.js_vars.continuous_updates is not defined or config.js_vars.continuous_updates is none %}null{% else %}{{ config.js_vars.continuous_updates | lower }}{% endif %};
        var slider_id = '{{ config.slider_id }}';
        {% endautoescape %}

        // This is called each time
        // To do - refactor this using psynet.trial.onEvent
        on_slider_event = function (event_type) {

        };

        // Metadata collection
        var slider = document.getElementById(slider_id);

        if (continuous_updates) {
            slider.log = "The slider log is disabled when continuous slider updates are enabled.";
        } else {
            slider.log = [];
        }

        // To do - refactor this into psynet.trial.eventLog
        slider.update_log = function() {
            if (!continuous_updates) {
                slider.log.push({
                    'time': new Date(),
                    'value': slider.value
                });
            }
        }

        slider.interaction_count = 0;

        snap_slider = function () {
            raw_value = parseFloat(slider.value);
            if (snap_values == null) {
                psynet.log.debug("Slider value: " + raw_value + " (no snapping).");
                return raw_value
            } else {
                new_value = psynet.utils.closest(slider.value, snap_values).value;
                slider.value = new_value;
                psynet.log.debug("Snapped slider from " + raw_value + " to " + new_value);
                return new_value;
            }
        };

        psynet.trial.onEvent("prepare", () => {
            snap_slider();
            on_slider_event('initialise');
            slider.update_log();
        })

        var slider_listener;

        if (continuous_updates) {
            slider_listener = "input";
        } else {
            slider_listener = "change";
        }

        let hadMinimalInteractions = false;
        let checkMinimalInteractions = function() {
            if (slider.interaction_count >= minimal_interactions && !hadMinimalInteractions) {
                hadMinimalInteractions = true;
                psynet.trial.registerEvent("sliderMinimalInteractions");
            }
        }

        psynet.trial.onEvent("trialConstruct", () => {
            checkMinimalInteractions();
            slider.addEventListener(slider_listener, function () {
                snap_slider();
                slider.interaction_count += 1;
                checkMinimalInteractions();
                on_slider_event('slider_changed');
                slider.update_log();
            }, false);
        });

        submit = function () {
            psynet.response.disable();
            psynet.submit.disable();
            var metadata = {
                log: slider.log
            };
            psynet.next_page(parseFloat(slider.value), metadata);
        };

        retrieve_response = function() {
            return {
                raw_answer: parseFloat(slider.value)
            }
        }
    </script>
    {% if config.template_filename %}
        {% include config.template_filename %}
    {% endif %}
{% endmacro %}

{% macro multi_slider(config) %}
    <style type="text/css">
        .slider-collection {
            margin: 30px;
        }

        .slider {
            margin: 20px;
        }

        input[type=range] {
            width: 50%;
            display: inline-block;
        }

        .slider-label {
            font-weight: bold;
            display: inline-block;
            min-width: 200px;
            text-align: right;
            margin-right: 20px;
        }

        .slider-value {
            width: 60px;
            display: inline-block;
            margin-left: 20px;
        }
    </style>

    <script>
        var init_sliders = function(){
            var slider = $('.slider'),
                range = $('.slider-range'),
                value = $('.slider-value');

            slider.each(function(){
                value.each(function(){
                    var value = $(this).prev().attr('value');
                    $(this).html(value);
                });

                range.on('input', function(){
                    $(this).next(value).html(this.value);
                });
            });
        };
        window.addEventListener("load", init_sliders);
    </script>

    <div class="slider-collection">
        {% for s in config.sliders %}
            <div class="slider">
                <span class="slider-label">
                    {{ s.label }}
                </span>
                <input
                    type="range"
                    id="{{ s.slider_id }}"
                    class="form-control-range response slider-range{% if not s.directional %} slider-non-directional{% endif %}"
                    style="display: inline-block;"
                    min="{{ s.min_value }}"
                    max="{{ s.max_value + 0.0001 * s.step_size }}"
                    step="{{ s.step_size }}"
                    value="{{ s.start_value }}">
                <span class="slider-value">NA</span>
            </div>
        {% endfor %}
    </div>
{% endmacro %}

{% macro audio_meter(config) %}
    <style>
        .audio_meter_block {
            margin-top: 20px;
            margin-bottom: 20px;
        }
    </style>
    <div class="audio_meter_block">
        <table style="width: 500px; padding: 10px">
            <tbody>
                <tr align="left" valign="middle">
                    <td width="300px">
                        <div style="background-color: black; width: 300px; height: 50px">
                            <canvas id="audio_meter" width="300" height="50"></canvas>
                        </div>
                    </td>
                    <td width="20px"></td>
                    <td align="left">
                        <p id="audio_meter_text" style="font-weight: bold; margin: 0px; display: none;"></p>
                    </td>
                </tr>
            </tbody>
        </table>

        {% if config.calibrate %}
            {{ audio_meter_calibrate(config) }}
        {% endif %}
    </div>

    {% if config.submit_button %}
        {{ null(config) }}
    {% endif %}

    <script>
        {% include "macros/control/audio_meter.js" %}
        audio_meter_control.init('{{ config.to_json() }}');
    </script>
{% endmacro %}

{% macro audio_meter_calibrate(config) %}
    <style type="text/css">
        #audio-meter-documentation {
            padding-top: 20px;
        }
    </style>

    <ul class="nav nav-tabs">
        <li class="nav-item">
            <a href="#audio-meter-sliders" class="nav-link" data-toggle="tab">Sliders</a>
        </li>
        <li class="nav-item">
            <a href="#audio-meter-documentation" class="nav-link" data-toggle="tab">Documentation</a>
        </li>
    </ul>

    <div class="tab-content">
        <div id="audio-meter-sliders" class="tab-pane active">
            {{ multi_slider(config.sliders) }}
        </div>

        <div id="audio-meter-documentation" class="tab-pane">
            <p>
                The <strong>decay</strong> parameters determine the amount of smoothing
                that happens to the signal, and have units of seconds. A high decay parameter
                means that the signal takes a long time to decay (i.e. high smoothing).
                There are three decay parameters: one for the displayed audio meter,
                one for the 'too-high' detector, and one for the 'too-low' detector.
            </p>
            <p>
                The <strong>threshold</strong> parameters determine the point at which
                the volume is determined to be 'too high' or 'too low'.
            </p>
            <p>
                The <strong>grace</strong> parameters determine how long the volume must be
                outside the respective threshold for a warning message to be triggered.
            </p>
            <p>
                The <strong>message duration</strong> parameters determine how long
                warning messages are displayed for.
            </p>
        </div>
    </div>

    <script>
        setInterval(() => audio_meter_control.update_from_sliders(), 50);
    </script>
{% endmacro %}

{% macro generic_record(config) %}
    {% if config.show_meter %}
        {{ audio_meter(config.meter) }}
    {% endif %}


    {% if config.controls %}
        <style>
            #record-controls {
                display: flex;
                justify-content: center;
                align-items: center;
                padding-bottom: 50px;
            }
            .record-button {
                margin-left: 10px;
                margin-right: 10px;
            }
            #record-loop {
                margin-left: 10px;
                margin-right: 10px;
            }
        </style>

        <div id="record-controls">
            <button id="btn-record-record" type="button" class="btn record-button auto-reset record-control btn-danger btn-sm" disabled>
                Record from start
            </button>
            <button id="btn-record-play-all" type="button" class="btn record-button auto-reset record-control btn-primary btn-sm" disabled>
                Play all
            </button>
            <button id="btn-record-play-prompt" type="button" class="btn record-button auto-reset record-control btn-primary btn-sm" disabled>
                Play prompt
            </button>
            <button id="btn-record-play-recording" type="button" class="btn record-button auto-reset record-control btn-primary btn-sm" disabled>
                Play recording
            </button>
            <button id="btn-record-stop" type="button" class="btn record-button auto-reset record-control btn-secondary btn-sm">
                Stop
            </button>
            <button id="btn-record-upload" type="button" class="btn record-button record-control btn-success btn-sm" disabled>
                <span id="btn-record-upload-spinner" class="spinner-border spinner-border-sm" role="status" aria-hidden="true" style="display: none"></span>
                <span>Upload</span>
            </button>
            <div id="record-loop">
                <input id="record-loop-input" class="record-control" type="checkbox" value="" {% if config.loop_playback %} checked {% endif %}>
                <label>Loop</label>
            </div>
        </div>
    {% endif %}

    <script>
        $(document).ready(function() {
            $(".auto-reset").on("click", function() {
                this.disabled = true;
                setTimeout(() => this.disabled = false, 500);
            });

            $("#btn-record-record").on("click", function() {
                replayMode = false;
                psynet.trial.restart();
            });

            $("#btn-record-play-all").on("click", function() {
                replayMode = true;
                psynet.media.stop_all_audio();
                psynet.trial.restart();
            });

            $("#btn-record-play-prompt").on("click", function() {
                psynet.trial.stop();
                let options = psynet.utils.shallow_copy(audioPromptPlayerOptions);
                options.loop = loop;
                psynet.media.stop_all_audio();
                psynet.audio.prompt.play(options);
            });

            $("#btn-record-play-recording").on("click", function() {
                playRecording();
            });

            $("#btn-record-stop").on("click", function() {
                psynet.media.stop_all_audio();
                psynet.trial.stop();
            });

            $("#record-loop-input").on("change", function(event) {
                loop = event.target.checked;
            });

            $("#btn-record-upload").on("click", function() {
                let spinner = $("#btn-record-upload-spinner");
                let button = $(this);
                button.prop("disabled", true);
                let resetButton = function() {
                    button.prop("disabled", true);
                    spinner.hide();
                }
                spinner.show();
                psynet.trial.registerEvent("uploadStart");
                psynet.trial.onEvent("uploadEnd", () => {
                    spinner.hide();
                    $("#next_button").click()
                });
                psynet.trial.onEvent("uploadFail", resetButton);
            });
        });

        let recorderControls = {{ config.controls | lower }};
        let replayMode = false;
        let loop = {{ config.loop_playback | tojson }};

        psynet.trial.onEvent("recordEnd", function() {
            if (!replayMode) {
                hasRecorded = true;
            }
            $("#btn-record-play-recording").attr("disabled", false);
            $("#btn-record-play-all").attr("disabled", false);
            $("#btn-record-upload").prop("disabled", false);

            if (!recorderControls) {
                psynet.trial.registerEvent("uploadStart");
            }
        }, {
            priority: -100 // ensures that this is only executed once all the media processing completes
        });

        psynet.trial.onEvent("trialStop", function() {
            psynet.media.stop_all_audio();
        });

        psynet.trial.onEvent("trialFinished", function() {
            if (loop) {
                psynet.trial.restart();
            }
        });

        psynet.trial.onEvent("trialPrepare", () => {
            psynet.media.stop_all_audio();
        });

        let supportedPrompts = ["audio"];
        if (!supportedPrompts.includes(modular_page_components.prompt)) {
            $("#btn-record-play-prompt").hide();
            $("#btn-record-play-all").hide();
        }

        psynet.trial.onEvent("trialStart", () => {
            if (psynet.audio.prompt) {
                $("#btn-record-play-prompt").prop("disabled", false);
            }
            $("#btn-record-record").prop("disabled", false);
        });

        function uploadToS3(blob, presignedUrl) {
            return new Promise(resolve => {
                // TODO upload if LOCAL_S3
                let xhr = new XMLHttpRequest();
                xhr.open('PUT', presignedUrl, true);

                xhr.onload = function(e) {
                    resolve(true);
                };

                let wavFile = new File([blob], "s3_upload.wav")
                xhr.send(wavFile);
            });
        };

    </script>

{% endmacro %}

{% macro audio_record(config) %}
    {{ generic_record(config) }}

    {{ null(config) }}

    <script>
        {% include "macros/control/recorder.js" %}

        {% autoescape off %}
        var presignedUrl = "{{ config.presigned_url }}";
        {% endautoescape %}

        var recorder;
        var hasRecorded = false;
        var recordingBlob;

        var playRecording = async function() {
            await psynet.audio.recording.play();
        }

        psynet.trial.onEvent("recordStart", function() {
            if (replayMode) {
                psynet.audio.recording.play();
            } else {
                recorder.clear();
                recorder.record();
            }
        });

        let getAudioRecording = function() {
            return new Promise(resolve => {
                recorder.exportWAV((blob) => resolve(blob));
            });
        }

        psynet.trial.onEvent("recordEnd", async function() {
            if (!replayMode) {
                await recorder.stop();
                recordingBlob = await getAudioRecording();
                let buffer = await psynet.media.blob_to_array_buffer(recordingBlob);
                await psynet.media.add_extra_audio_stimulus(buffer, "recording");
            }
        });

        psynet.trial.onEvent("uploadStart", async function() {
            try {
                await uploadToS3(recordingBlob, presignedUrl);
                // We don't want to wait for the following line, not sure how to get round
                // the linter complaining here.
                psynet.trial.registerEvent("uploadEnd", {info: {url: presignedUrl}});
            } catch(e) {
                psynet.trial.registerEvent("uploadFail");
                throw e;
            }
        });

        psynet.trial.onEvent("trialStop", () => recorder.stop());

        psynet.trial.onEvent("trialConstruct", () => new Promise((resolve) => {
            let channelCount = {{ config.num_channels }};
            navigator.mediaDevices.getUserMedia({
                audio: {
                    channelCount: channelCount,
                    autoGainControl: false,
                    echoCancellation: false,
                    noiseSuppression: false
                },
                video: false
            }).then(function(stream) {
                psynet.log.debug("Initialising audio recorder.");
                let input = psynet.media.audio_context.createMediaStreamSource(stream);
                recorder = new Recorder(input, channelCount);
                psynet.trial.registerEvent("audioRecorderReady");
                resolve();
            });
        }));

        retrieve_response = function() {
            return {
                raw_answer: presignedUrl
            }
        }
    </script>
{% endmacro %}

{% macro video_record(config) %}
    {{ generic_record(config) }}

    <style>
        #video-control-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #video-control {
            display: {% if config.show_preview %} block {% else %} none {% endif %};
            width: {{ config.width }};
            margin: 10px
        }
    </style>

    <div id="video-control-container">
        <video id="video-control"></video>
    </div>

    {{ null(config) }}

    <script>
        {% include "macros/control/RecordRTC.js" %}
        {% include "macros/control/adapter.js" %}

        {% autoescape off %}
        psynet.media.presignedUrlCamera = "{{ config.presigned_url_camera }}";
        psynet.media.presignedUrlScreen = "{{ config.presigned_url_screen }}";
        {% endautoescape %}

        let videoPlayer = document.getElementById('video-control');
        let screenVideo = document.getElementById('screen-recording');

        let recordingSource = "{{ config.recording_source | lower }}";
        let recordingCamera = recordingSource == "camera" || recordingSource == "both";
        let recordingScreen = recordingSource == "screen" || recordingSource == "both";

        if (recordingCamera) {
            let cameraStream = null;
            var videoRecorder = null;
            let audioSettings = null; 

            if ({{ config.record_audio | lower }}) {
                audioSettings = { 
                    channelCount: {{ config.audio_num_channels }} 
                };
            }
            else { audioSettings = false; }

            psynet.trial.onEvent("trialConstruct", () => new Promise((resolve) => {
                navigator.mediaDevices.getUserMedia({
                    audio: audioSettings,
                    video: true,
                }).then((stream) => {
                    psynet.log.debug("Initialising video recorder.");
                    cameraStream = stream;
                    resolve();
                }).catch((error) => {
                    throw new Error('Cannot start video recording:', error.name + ":", error.message);
                });
            }));

            psynet.trial.onEvent("trialConstruct", async function() {
                await loadCameraPreview();
            })

            psynet.trial.onEvent("trialPrepare", () => {
                if (!replayMode) {
                    videoRecorder = new RecordRTCPromisesHandler(cameraStream, {
                        mimeType: "video/webm",
                    });
                    videoRecorder.stream = cameraStream;
                }
            });

            psynet.trial.onEvent("trialPrepare", async function() {
                await loadCameraPreview();
            });

            var playRecording = async function() {
                await loadRecordedVideo();
                videoPlayer.play();
                videoPlayer.addEventListener("ended", loadCameraPreview, {once: true});
            };

            let videoDisplayMode = null;

            async function loadRecordedVideo() {
                if (videoDisplayMode == "playback") {
                    return;
                }
                videoPlayer.src = null;
                videoPlayer.srcObject = null;
                let blob = psynet.media.data.videoBlob;
                videoPlayer.src = URL.createObjectURL(blob);
                videoPlayer.muted = false;
                await videoPlayer.pause();
                videoDisplayMode = "playback";
            }

            async function loadCameraPreview() {
                if (videoDisplayMode == "preview") {
                    return;
                }
                videoPlayer.src = null;
                videoPlayer.srcObject = null;
                setSrcObject(cameraStream, videoPlayer);
                videoPlayer.muted = true;
                await videoPlayer.play();
                videoDisplayMode = "preview";
            }

            psynet.trial.onEvent("recordStart", async function() {
                if (replayMode) {
                    await playRecording();
                } else {
                    await videoRecorder.startRecording(videoRecorder.stream);
                }
            });

            psynet.trial.onEvent("recordEnd", async function() {
                if (!replayMode) {
                    await videoRecorder.stopRecording();
                    psynet.media.data["videoBlob"] = await videoRecorder.getBlob();
                    await videoRecorder.reset();
                }
            });

            psynet.trial.onEvent("trialStop", async function() {
                let state = await videoRecorder.getState();
                if (state != "inactive") {
                    await videoRecorder.stopRecording();
                }
                await videoRecorder.reset();
                await loadCameraPreview();
            });
        }

        let screenBlob = null;
        let screenRecorder = null;
        let screenStream = null;

        if (recordingScreen) {
            psynet.trial.onEvent("trialConstruct", () => new Promise((resolve) => {
                navigator.mediaDevices.getDisplayMedia({
                    video: true
                }).then((stream => {
                    screenStream = stream;
                    resolve(true);
                })).catch((error) => {
                    throw new Error("Unable to capture your screen. " + error.name + ":" + error.message);
                });
            }));

            psynet.trial.onEvent("trialPrepare", () => {
                if (!replayMode) {
                    screenRecorder = new RecordRTCPromisesHandler(screenStream, {
                        mimeType: 'video/webm'
                    });
                    screenRecorder.stream = screenStream;
                }
            });

            psynet.trial.onEvent("recordStart", function() {
                if (!replayMode) {
                    screenRecorder.startRecording();
                }
            });

            psynet.trial.onEvent("recordEnd", async function() {
                if (!replayMode) {
                    await screenRecorder.stopRecording();
                    psynet.media.data["screenBlob"] = await screenRecorder.getBlob();
                    await screenRecorder.reset();
                }
            });

            psynet.trial.onEvent("trialStop", async function() {
                let state = await screenRecorder.getState();
                if (state != "inactive") {
                    await screenRecorder.stopRecording();
                }
                await screenRecorder.reset();
            });

        }

        psynet.trial.onEvent("uploadStart", async function() {
            let promises = [];
            if (recordingCamera) {
                promises.push(uploadToS3(psynet.media.data["videoBlob"], psynet.media.presignedUrlCamera));
            }
            if (recordingScreen) {
                promises.push(uploadToS3(psynet.media.data["screenBlob"], psynet.media.presignedUrlScreen));
            }
            try {
                await Promise.all(promises);
                psynet.trial.registerEvent("uploadEnd");
            } catch(e) {
                psynet.trial.registerEvent("uploadFail");
                throw e;
            }
        });

        function retrieve_response() {
            return {
                raw_answer: {
                    'camera': psynet.media.presignedUrlCamera,
                    'screen': psynet.media.presignedUrlScreen,
                }
            }
        }
    </script>
{% endmacro %}

{% macro text(config) %}
    <style>
        #text_input_container {
            padding-top: 20px;
            padding-bottom: 20px;
            display: flex;
            justify-content: center;
        }
        #text_input {
            {% if config.width is not none %} width: {{ config.width }}; {% endif %}
            {% if config.height is not none %} height: {{ config.height }}; {% endif %}
        }
    </style>

    <div id="text_input_container">
        {% if config.one_line %}
            <input id="text_input" class="form-control response" type="text" value=""/>
        {% else %}
            <textarea id="text_input" class="form-control response" type="text"></textarea>
        {% endif %}
    </div>
    <p class="vspace"></p>

    <script>
        retrieve_response = function() {
            return {
                raw_answer: $("#text_input").get(0).value
            }
        }
    </script>

    {{ null(config) }}
{% endmacro %}

{% macro number(config) %}
    <style>
        #number_input_container {
            padding-top: 20px;
            padding-bottom: 20px;
            display: flex;
            justify-content: center;
        }
        #number_input {
            text-align: {{config.text_align}};
            {% if config.width is not none %}width: {{ config.width }};{% endif %}
        }
    </style>

    <div id="number_input_container">
        <input id="number_input" class="form-control response" type="text" value=""/>
    </div>
    <p class="vspace"></p>

    <script>
        retrieve_response = function() {
            return {
                raw_answer: $("#number_input").get(0).value
            }
        }
    </script>

    {{ null(config) }}
{% endmacro %}

{% macro video_slider(config) %}
    <style>
        #slider_video_container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 25px;
            min-height: {{ config.height }};
            min-width: {{ config.width }};
        }
        #slider_container {
            margin: 25px;
            {% if config.hide_slider == true %} display: none; {% endif %}
        }
        #slider {
            {%if config.reverse_scale %} direction: rtl {% endif %}
        }
        .slider-range {
            cursor: pointer;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            border: 1px solid #000000;
            height: 36px;
            background-color: #efefef;
            border: 11px solid #b2b2b2;
            border-radius: 5px;
            {% if config.directional == false %}
            margin-top: -8px;
            {% endif %}
            cursor: pointer;
        }
        {% if config.directional == false %}
        input[type=range]::-webkit-slider-runnable-track {
              background: #000000;
              border: 1px solid #b2b2b2;
              background-color: #efefef;
              border-radius: 5px;
              width: 100%;
              height: 8px;
            }
        {% endif %}
    </style>

    <div id="slider_video_container">
        <video id="slider_video" class="loader" width="{{ config.width }}" height="{{ config.height }}">
            <source src="" type="video/{{ config.file_type }}"
        </video>
    </div>

    {{config.__dict__}}
    <div id="slider_container">
        <input
            type="range"
            id="slider"
            class="form-control-range response slider-range{% if not config.directional %} slider-non-directional{% endif %}"
            style="display: inline-block;"
            min="0"
            max="1"
            step="0.001"
            value="{{ config.starting_value }}">
    </div>

    {{ null(config) }}

    <script>
        update_video_from_slider = function() {
            var slider_value = document.getElementById("slider").value;
            var video = document.getElementById("slider_video");
            if (psynet.response.ready_done && !isNaN(video.duration)) {
                video.currentTime = slider_value * video.duration;
            };
            window.requestAnimationFrame(update_video_from_slider);
        }
        update_video_from_slider();

        retrieve_response = function() {
            return {
                raw_answer: parseFloat($("#slider").get(0).value)
            }
        }
    </script>
{% endmacro %}

{% from "macros/graphics.html" import graphic_%}
{% macro graphic(config) %}
    {{ graphic_(config) }}
{% endmacro %}
